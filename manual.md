# nouzen

## はじめに
これはhempgreens（麻菜結）の自作したプログラミング言語、`nouzen`のマニュアルです。  
この言語は`BrainF**k`言語と`Forth`言語を参考にし`Python`にて実装しました。お遊び言語なので実用性はありませんが、私が楽しいのでOKです。  
`nouzen`という名前は、植物の凌霄花（ノウゼンカズラ）から来ています。「霄（そら）を凌ぐ花」の意味を持つこの植物のように、高く高く成長してほしいという願いから来ています。  
嘘です。本当は`BrainF**k`の`Brain`を抜き出して脳、`Forth`の日本語訳`前へ`から前、合わせて脳前です。まあインスパイアされたものからとってきただけの命名ですので深い意味はありません。  
それでは、以下より説明です。

## 環境

テスト環境は以下の通りです。

```
OS Windows10
Python 3.9.0
```

実行は以下のように行います。

```
> python nouzen.py sample/helloworld.nz
```

## 数値

数値は10進数、16進数、2進数を使うことが出来ます。以下のトークンは全て同じ意味です。

```
10 0xa 0b1010 0d10
```

また、文字を使うこともできます。以下は改行を示すエスケープシーケンスで、数値で言うと10です。

```
'\n'
```

また、マイナスを使うこともできます。二つのダブルコーテーションは空文字列ではなく絶対値を返す演算子です。

```
-10 ""
```

## 変数

変数とは特定の値を保持しておくことが出来る数値です。宣言はこのように行います。

```
0 $ value
```

変数の値をスタックに積むにはそのまま記述すれば良いです。

```
value
```

代入には宣言と同様に記述します。宣言されていない変数は宣言、されているなら代入といった感じです。

```
100 $ value
```

詳しい挙動は組込み演算子の`$`で説明します。

配列も使うことが出来ます。長さ5の配列を定義するのはこのようにします。

```
5 @ array
```

配列の各要素への代入はこのようにおこないます。arrayの3番目の要素に100を代入してみます。

```
100 3 @ array
100 3 @s array
```

また、取り出すには`@g`を使います。arrayの2番目の要素をスタックへ積みます。

```
2 @g array
```

配列はそのまま記述するとポインタアドレスを出力します。これをつかって参照することはできません。

```
array .i
# 2765082656064
```

詳しい挙動は組込み演算子の`@`で説明します。

## 条件分岐・ジャンプ・ループ構造

nouzenの制御構造は行ってしまえばgotoです。まず条件分岐を説明します。

```
1 ( "True" .s )
```

nouzenでは0がfalseな値で、その他は全てtrueです。演算子`(`はスタックトップの値がtrueな時に括弧の中を実行し、そうでは無いときは演算子`)`まで処理を飛ばします。逆にfalseな時に実行したい場合は

```
0 ! ( "False" .s )
```

`!`演算子を使います。この演算子はtrueな値をfalseに、falseな値をtrueにします。二回反転させたときに元の値に戻るわけではないのでご了承ください。

次にジャンプです。演算子は`[` `]`でこの挙動は常にtrueな時の条件分岐と変わりません。つまり下の例では

```
"A" .s [ "B" .s ] "C" .s
```

`AC`とだけ出力します。この二つを組み合わせると`if-else`文のようなものがつくれます。

```
1 ( "true" .s [ ) "false" .s ]
```

条件分岐の`(` `)`の中に入れるとジャンプ演算子`[` `]`が働かないのでこれで対応する場所に移動することができます。

次にループです。ループはこれまでのモノとは違い、後から前に移動します。

```
{ "Infinite Loop" .s }
```

ループは条件分岐とジャンプと組み合わせることで`for`や`while`のように使うことが出来ます。

```
5 { _
    _ .i        # Loop Content print countdown
! ( [ ) 1 - } ]
# 543210
```

`_`はスタックの値を複製します。5から1ずつ引き算してって、0になると`(` `)`の中身が実行されループの外側に脱出します。無限ループになってもこの言語には命令実行の回数制限があります。

```
limit over execute token
```

初期値は250,000回です。安心ですね。

これらの演算子の詳細な説明は組込み演算子のそれぞれの項で説明します。

## サブルーチン

サブルーチンは`:`のトークンで定義が始まり、`;`でサブルーチンの定義が終了します。

```
: greet "Hello" .s ;
greet
# Hello
```

関数から関数を呼び出すこともできます。

```
: greet "Hello" .s cr ;
: cr '\n' . ;

greet greet greet

# Hello
# Hello
# Hello
```

再帰呼出もできます。

```
: rec 1 - _ .i _ ( rec ) ;

10 rec

# 9876543210
```

変数や配列は全てグローバル変数なので、関数内から呼ぶこともできるし、関数で宣言されたものを使うこともできます。混同したくないときは工夫が必要です。

```
: add x y + ;

10 $ x 20 $ y add .i

# 30
```

```
: String "abcde" _str _str ;

String 2 @g _str .

# c
```

文字列の後に名前をおくと、文字配列の変数名として登録されます。`String`サブルーチンを実行した後、`_str`に入っていた`c`を`@g`で抜き出しました。

サブルーチン定義`:`、サブルーチンリターン`;`や文字列`" "`についての詳細は組込み演算子の各項目で説明します。


## 組込み演算子

ここでは、組込み演算子について説明します。

### 変数演算子
変数や配列を操作する演算子です。

- 変数定義　$

```
<init value> $ variable
```

スタックからポップ、その値を初期値とする変数名`variable`を定義します。配列やサブルーチンと同名に定義してしまったとき、意味を上書きします。

- 配列定義・要素格納　@ @s

```
<array length> @ array
<value> <index> @s array
```

スタックからポップ、その値を配列数とする変数名`array`を定義。ポップした値が0以下だった時、定義されず実行ステータスを5にします。  
もしすでに`array`が定義されていたとき、すでにポップした値を配列のインデックス、もう一回ポップしそれを格納する値として`array`に格納。インデックスが0未満、または配列外だったとき、実行ステータスを3にします。  
`@s`と`@`は同じ意味を持ちます。

- 要素取得　@g

```
<index> @g array
```

スタックからポップ、その値を配列のインデックスとして`array`の要素をスタックへポップします。  
インデックスが0未満、または配列外だったとき、実行ステータスを3にし、スタックへ0を積みます。

### 算術演算子
加減乗除と余りを計算します。  
スタックからポップ、その値をまず`B`とします。もう一度スタックからポップ、その値を`A`とします。

- 加算　+
```
<A> <B> +
```
`A+B`をしてその値をスタックへ積みます。

- 減算　-
```
<A> <B> -
```
`A-B`をしてその値をスタックへ積みます。

- 乗算　*
```
<A> <B> *
```
`A*B`をしてその値をスタックへ積みます。

- 除算　/
```
<A> <B> /
```
`A/B`をしてその商をスタックへ積みます。`B`が`0`だったとき、スタックへ`0`を積み、実行ステータスを6にします。

- 剰余算　%
```
<A> <B> %
```
`A/B`をしてその余りをスタックへ積みます。`B`が`0`だったとき、スタックへ`0`を積み、実行ステータスを6にします。


### ビット演算子

ビット演算をします。  
まずスタックをポップ、これを`C`とします。

- ビットAND　&
```
<value> <C> &
```
スタックをポップ、その値を`C`をビットAND演算をし、その値をスタックへ積みます。

- ビットOR　|
```
<value> <C> |
```
スタックをポップ、その値を`C`をビットOR演算をし、その値をスタックへ積みます。

- ビットXOR　^
```
<value> <C> ^
```
スタックをポップ、その値を`C`をビットXOR演算をし、その値をスタックへ積みます。

- ビットNOT　~
```
<C> ~
```
`C`をビット反転をし、その値をスタックへ積みます。

### 比較演算

スタックの上二つの値を比較し、比較した結果を積みます。また真偽を反転します。  
まずスタックをポップ、その値を`B`とします。

- 小なり　<
```
<A> <B> <
```
スタックをポップ、その値を`A`としたとき、
`A < B`のとき、`1`をスタックへ積みます。
そうでなければ、`0`をスタックへ積みます。

- 大なり　>
```
<A> <B> >
```
スタックをポップ、その値を`A`としたとき、
`A > B`のとき、`1`をスタックへ積みます。
そうでなければ、`0`をスタックへ積みます。

- 等号　=
```
<A> <B> <
```
スタックをポップ、その値を`A`としたとき、
`A = B`のとき、`1`をスタックへ積みます。
そうでなければ、`0`をスタックへ積みます。

- 真偽反転　!
```
<B> !
```
`B`の値が`0`のとき、スタックに`1`を積みます。
そうでなければ、スタックに`0`を積みます。


### 出力演算子

スタックからポップし、その値を標準出力に値を出力します。

- 文字出力　. .c
```
<value> .
<value> .c
```
値を文字として解釈し出力します。

- 整数出力　.i
```
<value> .i
```
値を10進数整数値として出力します。

- 16進数出力　.x
```
<value> .x
```
値を16進数整数値として出力します。

- 2進数出力　.b
```
<value> .b
```
値を2進数整数値として出力します。

- 文字列出力　.s
```
<string addr> .s
```
値を文字配列と解釈し、文字列として出力します。

### 条件分岐演算子

```
<cond> (  )
```

スタックからポップ、その値が`0`では無かったとき、`(  )`の内側を実行します。  
`0`だったとき、`(  )`の`)`へ処理を飛ばす。直近の`)`に移動するわけでは無く、対応関係をもち、ネストします。

```
    (       # X ->
        (   # Y ->
            # 
        )   # -> Y
    )       # -> X
```

### ジャンプ演算子

```
 [  ]
```

`[`にあたると対応する`]`へ無条件で移動します。直近の`]`へ移動するわけでは無く、対応関係をもち、ネストします。

```
    [       # goto X
        [   # goto Y
            #
        ]   # Y
    ]       # X
```

### ループ演算子

```
 { }
```

`}`にあたると対応する`{`へ無条件で移動する。ジャンプ演算子などで抜けない限り無限にループします。  
対応関係をもち、ネストします。

```
    {       # X
        {   # Y
            # 
        }   # goto Y
    }       # goto X
```

### サブルーチン演算子
```
 : subroutine ;
```

サブルーチン名`subroutine`として定義します。すでに存在する変数や配列、サブルーチンの名前と同一だったとき、意味を上書きします。

```
: cr 10 . ;             # 改行
: func $ a $ b a b + ;  # 足し算
10 20 func .i cr        # 30
: func $ a $ b a b * ;  # 掛け算
10 20 func .i cr        # 200
```


### その他

- 絶対値　""
```
<value> ""
```
スタックからポップした値の絶対値をスタックへ積みます。  
空文字ではありません。

- 乱数　''
```
<value> ''
```
スタックからポップ、その値未満、0以上の乱数を生成し、スタックへ積みます。  
空文字ではありません。

- 文字入力　?
```
 ?
```
文字列バッファが空だったとき、標準入力より文字を取得し文字列バッファに格納します。その後、バッファの先頭から1文字取り出しスタックへ積みます。
標準入力より取得した文字列の最後にヌル文字'\0'が区切り文字として付与されています。

- 複製　_
```
<value> _
```
スタックからポップ、その値を2回スタックへ積みます。

- 削除　\`
```
<value> `
```
スタックからポップ、その値を捨てます。

- 実行ステータス演算子　,
```
 ,
```
現在の実行ステータスを取得、スタックに積みます。

|数値|意味|
|:-:|:-:|
|0|正常|
|1|スタックが空|
|2|無効なトークンを実行した|
|3|配列外へのアクセスが行われた|
|4|無効なエスケープシーケンスが発見された|
|5|配列の無効な宣言がなされた|
|6|0で除算が行われた|
|7|`.s`が用いたポインタが配列のポインタではなかった|


## 特殊演算子
バックスラッシュが付いた特殊な機能を提供する演算子。

- \dstack
```
 \dstack
```

現在のスタックの状況を出力する。

```
10 20 30 \dstack
# <3> 10 20 30
```


- \dshitory
```
<number> \dhistory
```
スタックからポップ、その値の件数だけ遡って何のトークンが実行されたか表示、0以下の数値が指定された場合、15回となる。

```
10 20 + .i
5 \dhistory

# 30[-4](20)
# [-3](+)
# [-2](.i)
# [-1](5)
# [0](\dhistory)
```

- \pause
```
 \pause
```
エンターキーを押すまでプログラムを中断する。

- \sleep
```
<time> \sleep
```
スタックをポップ、その値のミリ秒時間を停止する。

- \tracetoken
```
<bool> \tracetoken
```
スタックをポップ、その値が`0`意外だったとき、現在実行されているトークンを表示する。もう一度`0`を指定すると追跡をやめる。


- \limittoken
```
<number> \limittoken
```
スタックをポップ、その値をトークン実行回数制限を設定する。  
標準では250,000回となっている。

## 文字列・文字

### 文字列
```
 " "
 " " name
```

文字列を定義します。後ろに名前として指定可能な文字列が並んでいた時、`name`という名前の配列を定義し文字を格納します。既に存在する変数や配列、サブルーチンと名前が同一だった時、意味を上書きします。

そうではなかったとき、ポインタをスタックへ積みます。この値を`.s`で出力すると文字列が出力することが出来ます。
配列なので`@s`、`@g`によって文字の格納、取得が出来ます。

### 文字
```
 ' '
```
文字をスタックに積みます。概ね数値トークンと同じです。非対応なエスケープシーケンスが入力された時、`0`がスタックへ積まれ、実行ステータスに`4`が格納されます。

## エスケープシーケンス

文字列や文字ではエスケープシーケンスを使うことが出来る。対応するエスケープシーケンスは以下の通りとなっている。

|エスケープシーケンス|意味|数値|
|:--:|:----------:|:-:|
|`\\`|バックスラッシュ|92|
|`\"`|ダブルコーテーション|39|
|`\'`|シングルコーテーション|34|
|`\a`|ビープ音|7|
|`\b`|バックスペース|8|
|`\f`|フォームフィード|12|
|`\n`|ラインフィード|10|
|`\r`|キャリッジリターン|13|
|`\t`|水平タブ|9|
|`\v`|垂直タブ|11|
|`\e`|エスケープ|27|
|`\0`|ヌル文字|0|

## コメント

プログラムに解釈しないコメント文字列を記述することが出来ます。

```
# line comment
##
    comment out
##
```

`#`は行末までコメントとみなします。  
`##`はもう片方の`##`見つかるまで無視します。コメントは対応関係を持たず、直近の`##`まで無視します。ネストしません。

ちなみに、下の例では正しくコメントアウト出来ていません。

```
#invalidcomment
##invalid  comment##
```

`#`や`##`をコメントにしたい文字とすぐ隣に書くと、コメントとして消せません。スペースをはさんでください。

## マクロ

nouzenには置換マクロ機能があります。例えば以下のように使います。

```
### FALSE 0

#FALSE      # 0をスタックに積む
```

マクロとして登録したい文字列を`###`で始め、その後にマクロ名を記述し、置換内容を記述します。  
複数文字を置換することもできます。
```
### DO $ i $ lim i { $ i i _ lim < ! ( [ )
### LOOP 1 + } ]
: cr '\n' . ;

10 0 #DO
    i .i cr
#LOOP
```
Forth言語みたいですね。


## 外部参照

nouzenには多言語で言う`import`のような外部のプログラムを参照する機能があります。`##>`の後に記述します。

```
##> libraly.nz

greet
```

参照というか、呼び出したプログラムをソースコード上のその位置に転写するようなイメージです。ですのでマクロやサブルーチン、変数を引き継ぎ、実行される何かがあれば実行します。

```
##> libraly.nz xxx.nz yyy.nz
```

一行で複数参照することもできます。参照は相対パスでなされます。

## 更新日
&emsp; 2022/3/22 hempgreens